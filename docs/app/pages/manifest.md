# Manifests

One of the trickier parts of making a full stack app is getting all the pieces to work together. This is where manifests come in. A manifest is a file that tells the runtime what the bundler did and how to run the app.  The runtime uses the manifest to know what files to serve and how to serve them.

The real tricky part is making it work the same during DEV and PROD.

- **Development**: the manifest is generated on the fly, vite-style.
- **Production**: the manifest is generated by the bundler and then saved to disk. The runtime then reads the manifest from disk.

The manifest API is also the same between the server and client. The only difference is that the client manifest just has access to the router that's serving it.

You can access the manifest for any router by using `import.meta.env.MANIFEST['<router-name>']`.  This will give you a manifest object that looks like this:

```ts
type Manifest = {
  /** Name of the router */
  name: string;

  /** Handler path for the router */
  handler: string;

  inputs: {
    [key: string]: {
      /** Assets needed by this entry point */
      assets(): Promise<Asset[]>;

      output: {
        /** Path to built artifact for this entry point. */
        path: string;
      };
    };
  };

  chunks: {
    [key: string]: {
      assets(): Promise<Asset[]>;
      output: {
        path: string;
      };
    };
  };

  /**
   * Seriazable JSON representation of the manifest
   * Useful for sending to the client and hydrating the runtime
   * by assigning it to `window.manifest`
   */
  json(): object;

  /** Map of assets needed by the inputs and chunks */
  assets(): Promise<{ [key: string]: Asset[] }>;
}

```
